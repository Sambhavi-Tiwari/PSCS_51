# -*- coding: utf-8 -*-
"""Speech Enhancement Unet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ggBG5Mn1BeRE2_HaAmpBHnJXY04gN8W4
"""

!pip install torch torchaudio librosa tqdm --quiet

import os
import torch
import torch.nn as nn
import torch.optim as optim
import torchaudio
from torch.utils.data import Dataset, DataLoader
import librosa
import glob
from tqdm import tqdm

class NoizeusDataset(Dataset):
    def __init__(self, noisy_dir, clean_dir, sr=16000):
        self.noisy_files = sorted(glob.glob(os.path.join(noisy_dir, "*.wav")))
        self.clean_files = sorted(glob.glob(os.path.join(clean_dir, "*.wav")))
        self.sr = sr

    def __len__(self):
        return len(self.noisy_files)

    def __getitem__(self, idx):
        noisy, _ = librosa.load(self.noisy_files[idx], sr=self.sr)
        clean, _ = librosa.load(self.clean_files[idx], sr=self.sr)

        # Pad or truncate to 1 second (16000 samples)
        noisy = noisy[:16000] if len(noisy) >= 16000 else \
                librosa.util.fix_length(noisy, 16000)
        clean = clean[:16000] if len(clean) >= 16000 else \
                librosa.util.fix_length(clean, 16000)

        return torch.tensor(noisy).float(), torch.tensor(clean).float()

class UNet1D(nn.Module):
    def __init__(self):
        super().__init__()
        self.enc1 = nn.Sequential(nn.Conv1d(1, 16, 15, stride=2, padding=7), nn.ReLU())
        self.enc2 = nn.Sequential(nn.Conv1d(16, 32, 15, stride=2, padding=7), nn.ReLU())
        self.enc3 = nn.Sequential(nn.Conv1d(32, 64, 15, stride=2, padding=7), nn.ReLU())
        self.dec3 = nn.Sequential(nn.ConvTranspose1d(64, 32, 15, stride=2, padding=7, output_padding=1), nn.ReLU())
        self.dec2 = nn.Sequential(nn.ConvTranspose1d(64, 16, 15, stride=2, padding=7, output_padding=1), nn.ReLU())
        self.dec1 = nn.ConvTranspose1d(32, 1, 15, stride=2, padding=7, output_padding=1)

    def forward(self, x):
        x1 = self.enc1(x)
        x2 = self.enc2(x1)
        x3 = self.enc3(x2)
        d3 = self.dec3(x3)
        d2 = self.dec2(torch.cat([d3, x2], dim=1))
        d1 = self.dec1(torch.cat([d2, x1], dim=1))
        return torch.tanh(d1)

def train_model(noisy_dir, clean_dir, epochs=5, batch_size=8, lr=1e-3):
    dataset = NoizeusDataset(noisy_dir, clean_dir)
    loader = DataLoader(dataset, batch_size=batch_size, shuffle=True)

    model = UNet1D().cuda()
    optimizer = optim.Adam(model.parameters(), lr=lr)
    criterion = nn.MSELoss()

    for epoch in range(epochs):
        model.train()
        epoch_loss = 0
        for noisy, clean in tqdm(loader, desc=f"Epoch {epoch+1}/{epochs}"):
            noisy, clean = noisy.cuda(), clean.cuda()
            noisy, clean = noisy.unsqueeze(1), clean.unsqueeze(1)  # (B,1,T)

            out = model(noisy)
            loss = criterion(out, clean.unsqueeze(1))

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            epoch_loss += loss.item()

        print(f"Epoch {epoch+1}, Loss: {epoch_loss/len(loader):.4f}")

    torch.save(model.state_dict(), "unet_noizeus.pth")
    return model

from google.colab import drive
drive.mount('/content/drive')

!ls "/content/drive/MyDrive"

!ls "/content/drive/MyDrive/Speech enhancement"

noisy_dir = "/content/drive/MyDrive/Speech enhancement/0dB"   # noisy wav files
clean_dir = "/content/drive/MyDrive/Speech enhancement/clean"   # clean wav files

model = train_model(noisy_dir, clean_dir, epochs=50)

model.eval()
test_noisy, _ = librosa.load(glob.glob(noisy_dir+"/*.wav")[0], sr=16000)
x = torch.tensor(test_noisy).float().unsqueeze(0).unsqueeze(0).cuda()

with torch.no_grad():
    enhanced = model(x).cpu().squeeze().numpy()

import os

# get the path of the noisy file we just loaded
test_noisy_file = glob.glob(noisy_dir+"/*.wav")[0]

# create enhanced folder
os.makedirs("/content/enhanced", exist_ok=True)

# save with matching filename
out_path = "/content/enhanced/" + os.path.basename(test_noisy_file)
torchaudio.save(out_path, torch.tensor(enhanced).unsqueeze(0), 16000)
print("Enhanced file saved as", out_path)

!pip install pesq

!pip install pystoi

import os
import numpy as np
import soundfile as sf
from pesq import pesq
from pystoi import stoi
import math

def si_sdr(reference, estimate, eps=1e-8):
    # make sure numpy arrays
    ref = np.asarray(reference).astype(np.float64)
    est = np.asarray(estimate).astype(np.float64)
    # remove DC
    ref = ref - np.mean(ref)
    est = est - np.mean(est)
    # scale-invariant projection
    alpha = np.dot(est, ref) / (np.dot(ref, ref) + eps)
    target = alpha * ref
    noise = est - target
    si_sdr_value = 10 * np.log10((np.sum(target**2) + eps) / (np.sum(noise**2) + eps))
    return si_sdr_value

def load_and_align(clean_path, test_path, sr=16000):
    # loads as mono at sr (soundfile preserves sample rate; ensure files are at sr)
    ref, ref_sr = sf.read(clean_path)
    est, est_sr = sf.read(test_path)
    if ref_sr != sr:
        raise ValueError(f"Reference sample rate {ref_sr} != expected {sr}")
    if est_sr != sr:
        raise ValueError(f"Estimate sample rate {est_sr} != expected {sr}")
    # if different length, trim to min
    min_len = min(len(ref), len(est))
    ref = ref[:min_len]
    est = est[:min_len]
    return ref, est

def evaluate_one(clean_path, noisy_path, enhanced_path, sr=16000):
    # load & align
    clean_ref, noisy = load_and_align(clean_path, noisy_path, sr=sr)
    clean_ref, enhanced = load_and_align(clean_path, enhanced_path, sr=sr)

    # PESQ (wideband)
    try:
        pesq_noisy = pesq(sr, clean_ref, noisy, 'wb')
    except Exception as e:
        pesq_noisy = None
        print("PESQ(noisy) error:", e)
    try:
        pesq_enh = pesq(sr, clean_ref, enhanced, 'wb')
    except Exception as e:
        pesq_enh = None
        print("PESQ(enhanced) error:", e)

    # STOI
    try:
        stoi_noisy = stoi(clean_ref, noisy, sr, extended=False)
        stoi_enh = stoi(clean_ref, enhanced, sr, extended=False)
    except Exception as e:
        stoi_noisy = None
        stoi_enh = None
        print("STOI error:", e)

    # SI-SDR
    try:
        si_sdr_noisy = si_sdr(clean_ref, noisy)
        si_sdr_enh = si_sdr(clean_ref, enhanced)
    except Exception as e:
        si_sdr_noisy = None
        si_sdr_enh = None
        print("SI-SDR error:", e)

    # quick MOS approximation from PESQ (linear mapping)
    # NOTE: This is a coarse approximation for quick insight only.
    def pesq_to_mos(p):
        if p is None: return None
        # PESQ ranges roughly [-0.5, 4.5] -> MOS [1,5]
        return 1.0 + 0.8 * (p + 0.5)

    mos_noisy = pesq_to_mos(pesq_noisy)
    mos_enh = pesq_to_mos(pesq_enh)

    results = {
        'pesq_noisy': pesq_noisy,
        'pesq_enhanced': pesq_enh,
        'stoi_noisy': stoi_noisy,
        'stoi_enhanced': stoi_enh,
        'si_sdr_noisy': si_sdr_noisy,
        'si_sdr_enhanced': si_sdr_enh,
        'mos_noisy_approx': mos_noisy,
        'mos_enhanced_approx': mos_enh
    }
    return results

clean_path = "/content/drive/MyDrive/Speech enhancement/clean/sp11.wav"
noisy_path = "/content/drive/MyDrive/Speech enhancement/0dB/sp11_station_sn0.wav"
enhanced_path = "sp11_station_sn0.wav"

import librosa
import soundfile as sf

def resample_to_16k(in_path, out_path):
    y, sr = librosa.load(in_path, sr=16000)  # force resample
    sf.write(out_path, y, 16000)

# Example for your files
resample_to_16k(clean_path, "/content/tmp_clean_16k.wav")
resample_to_16k(noisy_path, "/content/tmp_noisy_16k.wav")
resample_to_16k("/content/enhanced/" + enhanced_path, "/content/tmp_enhanced_16k.wav")

# now evaluate with the resampled versions
res = evaluate_one("/content/tmp_clean_16k.wav",
                   "/content/tmp_noisy_16k.wav",
                   "/content/tmp_enhanced_16k.wav",
                   sr=16000)
for k,v in res.items():
    print(f"{k}: {v}")

"""This command installs the `pesq` library, which is required to calculate the Perceptual Evaluation of Speech Quality (PESQ) score. Once installed, the code in the selected cell should run without the `ModuleNotFoundError`."""